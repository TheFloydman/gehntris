{"version":3,"file":"gehntris.js","mappings":"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","sources":["webpack://Gehntris/./gehntris-objects.ts","webpack://Gehntris/webpack/bootstrap","webpack://Gehntris/./gehntris.ts"],"sourcesContent":["export class Board {\r\n\r\n    squareSize: number;\r\n    width: number;\r\n    height: number;\r\n    state: Square[][] | undefined[][] = [];\r\n\r\n    constructor(squareSize: number, width: number, height: number) {\r\n        this.squareSize = squareSize;\r\n        this.width = width;\r\n        this.height = height;\r\n        this.clear();\r\n    }\r\n\r\n    clear() {\r\n        for (let i = 0; i < this.height; i++) {\r\n            this.state[i] = [];\r\n            for (let j = 0; j < this.width; j++) {\r\n                this.state[i][j] = undefined;\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n\r\nexport class PieceTemplate {\r\n\r\n    shape: boolean[][];\r\n    fill: string;\r\n    weight: number;\r\n\r\n    constructor(shape: boolean[][], fill: string, weight: number) {\r\n        this.shape = shape;\r\n        this.fill = fill;\r\n        this.weight = weight;\r\n    }\r\n\r\n}\r\n\r\nclass Square {\r\n\r\n    x: number;\r\n    y: number;\r\n    piece: PieceInPlay;\r\n    svgElement: SVGElement;\r\n    fill: string;\r\n    isShadow: boolean;\r\n\r\n    constructor(x: number, y: number, fill: string, isShadow: boolean) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.fill = fill;\r\n        this.isShadow = isShadow;\r\n    }\r\n\r\n    draw(x: number, y: number, board: Board, svgCanvas: SVGElement, waiting: boolean = false) {\r\n        this.svgElement = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\r\n\r\n        function createSquare(size: number, x: number, y: number, fill: string, opacity: string = \"100%\"): SVGRectElement {\r\n            const rectElement = document.createElementNS(\"http://www.w3.org/2000/svg\", \"rect\");\r\n            rectElement.setAttribute(\"width\", size.toString());\r\n            rectElement.setAttribute(\"height\", size.toString());\r\n            rectElement.setAttribute(\"x\", x.toString());\r\n            rectElement.setAttribute(\"y\", y.toString());\r\n            rectElement.setAttribute(\"fill\", fill);\r\n            rectElement.setAttribute(\"fill-opacity\", opacity);\r\n            return rectElement;\r\n        }\r\n\r\n        const svgBorderTL = createSquare(\r\n            board.squareSize,\r\n            x + (this.x * board.squareSize),\r\n            y + (this.y * board.squareSize),\r\n            \"#666666\"\r\n        );\r\n\r\n        const svgBorderBR = createSquare(\r\n            board.squareSize - 1,\r\n            x + (this.x * board.squareSize) + 1,\r\n            y + (this.y * board.squareSize) + 1,\r\n            \"#CCCCCC\"\r\n        );\r\n\r\n        const svgBorderBL = createSquare(\r\n            1,\r\n            x + (this.x * board.squareSize),\r\n            y + (this.y * board.squareSize) + 7,\r\n            \"#999999\"\r\n        );\r\n\r\n        const svgBorderTR = createSquare(\r\n            1,\r\n            x + (this.x * board.squareSize) + 7,\r\n            y + (this.y * board.squareSize),\r\n            \"#999999\"\r\n        );\r\n\r\n        const svgBorderFill = createSquare(\r\n            board.squareSize - 2,\r\n            x + (this.x * board.squareSize) + 1,\r\n            y + (this.y * board.squareSize) + 1,\r\n            \"#FFFFFF\"\r\n        );\r\n\r\n        const svgBorderOverlay = createSquare(\r\n            board.squareSize,\r\n            x + (this.x * board.squareSize),\r\n            y + (this.y * board.squareSize),\r\n            this.fill,\r\n            \"50%\"\r\n        );\r\n\r\n        if (!this.isShadow) {\r\n            this.svgElement.append(svgBorderTL, svgBorderBR, svgBorderBL, svgBorderTR, svgBorderFill);\r\n        }\r\n        this.svgElement.append(svgBorderOverlay);\r\n        svgCanvas.append(this.svgElement);\r\n    }\r\n\r\n    canMove(x: number, y: number, board: Board): boolean {\r\n        const newX = this.x + x;\r\n        const newY = this.y + y;\r\n        const newSpaceOccupied = board.state[newY] && board.state[newY][newX];\r\n        const leftWallCrossed = newX < 0;\r\n        const rightWallCrossed = newX >= board.width;\r\n        const ceilingCrossed = newY < 0;\r\n        const floorCrossed = newY >= board.height;\r\n        return !newSpaceOccupied && !leftWallCrossed && !rightWallCrossed && !ceilingCrossed && !floorCrossed;\r\n    }\r\n\r\n    move(x: number, y: number, board: Board) {\r\n        if (this.canMove(x, y, board)) {\r\n            this.setPos(this.x + x, this.y + y);\r\n        }\r\n    }\r\n\r\n    setPos(x: number, y: number) {\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n\r\n}\r\n\r\nexport class PieceInPlay {\r\n\r\n    template: PieceTemplate;\r\n    squares: Square[] = [];\r\n    shadowSquares: Square[] = [];\r\n    border: string;\r\n    fill: string;\r\n    waiting: boolean;\r\n    stored: boolean = false;\r\n    ticksAlive: number = 0;\r\n\r\n    constructor(template: PieceTemplate, waiting: boolean = false) {\r\n        this.template = template;\r\n        this.fill = template.fill;\r\n        this.waiting = waiting;\r\n        for (let i = 0; i < template.shape.length; i++) {\r\n            for (let j = 0; j < template.shape[i].length; j++) {\r\n                if (template.shape[i][j]) {\r\n                    this.squares.push(new Square(j, i, this.fill, false));\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    draw(x: number, y: number, board: Board) {\r\n        if (!this.waiting && !this.stored) {\r\n            this.drawShadow(board);\r\n        }\r\n        for (let i = 0; i < this.squares.length; i++) {\r\n            let svgElement = svgMain();\r\n            if (this.waiting) svgElement = svgUpcoming();\r\n            if (this.stored) svgElement = svgStorage();\r\n            this.squares[i].draw(x, y, board, svgElement, this.waiting);\r\n        }\r\n    }\r\n\r\n    drawShadow(board: Board) {\r\n        for (let i = 0; i < this.shadowSquares.length; i++) {\r\n            this.shadowSquares[i].svgElement.remove();\r\n        }\r\n        this.shadowSquares = [];\r\n        let yOffset = 1;\r\n        while (this.canMove(0, yOffset, board)) {\r\n            yOffset++;\r\n        }\r\n        yOffset--;\r\n        for (let i = 0; i < this.squares.length; i++) {\r\n            this.shadowSquares.push(new Square(this.squares[i].x, this.squares[i].y + yOffset, \"#A0A0A0\", true));\r\n        }\r\n        for (let i = 0; i < this.shadowSquares.length; i++) {\r\n            this.shadowSquares[i].draw(0, 0, board, svgMain());\r\n        }\r\n    }\r\n\r\n    canMove(x: number, y: number, board: Board): boolean {\r\n\r\n        for (let i = 0; i < this.squares.length; i++) {\r\n            const currentSquare = this.squares[i];\r\n            if (!currentSquare.canMove(x, y, board)) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n\r\n    }\r\n\r\n    move(x: number, y: number, board: Board) {\r\n\r\n        let canMove = this.canMove(x, y, board);\r\n\r\n        if (canMove) {\r\n            for (let i = 0; i < this.squares.length; i++) {\r\n                const currentSquare = this.squares[i];\r\n                currentSquare.move(x, y, board);\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    setPos(x: number, y: number) {\r\n        const minX = Math.min(...this.squares.map(square => square.x));\r\n        const minY = Math.min(...this.squares.map(square => square.y));\r\n        for (let i = 0; i < this.squares.length; i++) {\r\n            const currentSquare = this.squares[i];\r\n            currentSquare.setPos(currentSquare.x - minX + x, currentSquare.y - minY + y);\r\n        }\r\n    }\r\n\r\n    drop(board: Board) {\r\n        let yOffset = 1;\r\n        while (this.canMove(0, yOffset, board)) {\r\n            yOffset++;\r\n        }\r\n        yOffset--;\r\n        this.move(0, yOffset, board);\r\n    }\r\n\r\n    /** Returns true if the spaces this piece occupies are empty. */\r\n    convert(board: Board): boolean {\r\n        for (let i = 0; i < this.squares.length; i++) {\r\n            const currentSquare = this.squares[i];\r\n            if (board.state[currentSquare.y][currentSquare.x]) {\r\n                return false;\r\n            }\r\n            board.state[currentSquare.y][currentSquare.x] = currentSquare;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    rotate(board: Board) {\r\n        const offsetX = Math.min(...this.squares.map(square => square.x));\r\n        const offsetY = Math.min(...this.squares.map(square => square.y));\r\n        const output = this.rotate2DArray(this.template.shape);\r\n        const newSquares: Square[] = [];\r\n\r\n        // Generate new squares based on the rotated shape\r\n        for (let i = 0; i < output.length; i++) {\r\n            for (let j = 0; j < output[i].length; j++) {\r\n                if (output[i][j]) {\r\n                    newSquares.push(new Square(offsetX + j, offsetY + i, this.fill, false));\r\n                }\r\n            }\r\n        }\r\n\r\n        // Check if the new squares are within bounds and not overlapping existing pieces\r\n        let minX = Math.min(...newSquares.map(square => square.x));\r\n        let maxX = Math.max(...newSquares.map(square => square.x));\r\n        let minY = Math.min(...newSquares.map(square => square.y));\r\n        let maxY = Math.max(...newSquares.map(square => square.y));\r\n\r\n        let moveX = 0;\r\n        let moveY = 0;\r\n\r\n        if (minX < 0) {\r\n            moveX = -minX;\r\n        } else if (maxX >= board.width) {\r\n            moveX = board.width - 1 - maxX;\r\n        }\r\n\r\n        if (minY < 0) {\r\n            moveY = -minY;\r\n        } else if (maxY >= board.height) {\r\n            moveY = board.height - 1 - maxY;\r\n        }\r\n\r\n        for (let square of newSquares) {\r\n            square.x += moveX;\r\n            square.y += moveY;\r\n        }\r\n\r\n        // Check if the adjusted new squares are valid\r\n        const isValid = newSquares.every(square => {\r\n            const x = square.x;\r\n            const y = square.y;\r\n            return x >= 0 && x < board.width && y >= 0 && y < board.height && (!board.state[y] || !board.state[y][x]);\r\n        });\r\n\r\n        if (isValid) {\r\n            this.template = new PieceTemplate(output, this.fill, 1);\r\n            this.squares = newSquares;\r\n        }\r\n    }\r\n\r\n    rotate2DArray(array: any[][]) {\r\n        const result: any[] = [];\r\n        array.forEach(function (a, i, aa) {\r\n            a.forEach(function (b, j, bb) {\r\n                result[j] = result[j] || [];\r\n                result[j][aa.length - i - 1] = b;\r\n            });\r\n        });\r\n        return result;\r\n    }\r\n\r\n}\r\n\r\nexport function svgMain(): SVGElement {\r\n    return <SVGElement><unknown>document.getElementById(\"svg-main\");\r\n}\r\n\r\nexport function svgUpcoming(): SVGElement {\r\n    return <SVGElement><unknown>document.getElementById(\"svg-upcoming\");\r\n}\r\n\r\nexport function svgStorage(): SVGElement {\r\n    return <SVGElement><unknown>document.getElementById(\"svg-storage\");\r\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","import { Board, PieceTemplate, PieceInPlay, svgMain, svgUpcoming, svgStorage } from \"./gehntris-objects\";\r\n\r\nconst colorCombos = [\r\n    \"#FF0000\", /* red */\r\n    \"#00FF00\", /* green */\r\n    \"#FFAF2E\", /* orange */\r\n    \"#0000FF\", /* blue */\r\n    \"#8D28B8\", /* violet */\r\n    \"#FFFF00\" /* yellow */\r\n];\r\nconst randomIndices: number[] = [];\r\nwhile (randomIndices.length < colorCombos.length) {\r\n    var random = Math.floor(Math.random() * colorCombos.length);\r\n    if (randomIndices.indexOf(random) === -1 && random < colorCombos.length) {\r\n        randomIndices.push(random);\r\n    }\r\n}\r\nconst allTemplates: PieceTemplate[] = [];\r\n\r\nconst squareSize = 8;\r\nconst boardSize = { x: 10, y: 25 };\r\nconst upcomingSize = { x: 5, y: 4 };\r\nconst storageSize = { x: 5, y: 5 };\r\nconst board: Board = new Board(squareSize, boardSize.x, boardSize.y);\r\n\r\nlet tickTime = 1000;\r\nlet tickTimer: NodeJS.Timeout;\r\nlet pieceInPlay: PieceInPlay;\r\nlet pieceUpcoming: PieceInPlay;\r\nlet pieceStored: PieceInPlay;\r\nlet okayToAddPiece = true;\r\nlet isGameOver = false;\r\nlet isPaused = true;\r\nlet score = 0;\r\nlet linesCleared = 0;\r\nlet gameTicks = 0;\r\nlet actionHandled = false;\r\nlet touchStartX = 0;\r\nlet touchStartY = 0;\r\nlet touchEndX = 0;\r\nlet touchEndY = 0;\r\nlet touchTime = 50;\r\nlet touchTimer: NodeJS.Timeout = undefined;\r\nlet timeDown = 0;\r\nlet cancelNext = false;\r\nlet skipNextDown = false;\r\nlet skipTicks = 0;\r\nlet swappedThisTurn = false;\r\nlet mouseDownOverPauseButton = false;\r\nlet mouseDownInStorage = false;\r\n\r\nexport async function onBodyLoad() {\r\n    await setupPieceTemplates();\r\n    setBoardProperties();\r\n    addEventListeners();\r\n}\r\n\r\nasync function setupPieceTemplates() {\r\n    const templates = await fetch(\"./templates.json\");\r\n    const json = await templates.json();\r\n    for (let i = 0; i < json.templates.length; i++) {\r\n        const template = json.templates[i];\r\n        const pieceTemplate = new PieceTemplate(template.shape, colorCombos[randomIndices[i]], template.weight);\r\n        allTemplates.push(pieceTemplate);\r\n    }\r\n}\r\n\r\nfunction setBoardProperties() {\r\n    svgMain().setAttribute(\"viewBox\", `0 0 ${boardSize.x * squareSize} ${boardSize.y * squareSize}`);\r\n\r\n    svgUpcoming().setAttribute(\"viewBox\", `0 0 ${upcomingSize.x * squareSize} ${upcomingSize.y * squareSize}`);\r\n\r\n    svgStorage().setAttribute(\"viewBox\", `0 0 ${storageSize.x * squareSize} ${storageSize.y * squareSize}`);\r\n\r\n    addPieceToWaiting();\r\n}\r\n\r\nfunction addPieceToWaiting() {\r\n    const totalWeight: number = allTemplates.map(template => template.weight).reduce((sum, weight) => sum + weight, 0);\r\n    let currentValue = 0;\r\n    const weightMap = allTemplates.reduce((map, template) => {\r\n        map.set([currentValue, currentValue + (template.weight / totalWeight)], template);\r\n        currentValue += template.weight / totalWeight;\r\n        return map;\r\n    }, new Map<number[], PieceTemplate>());\r\n    let chosenTemplate: PieceTemplate | undefined;\r\n    const entries = weightMap.entries();\r\n    while (!chosenTemplate) {\r\n        const random = Math.random();\r\n        for (const [range, template] of entries) {\r\n            if (random >= range[0] && random <= range[1]) {\r\n                chosenTemplate = template;\r\n            }\r\n        }\r\n    }\r\n    const foo = new PieceInPlay(chosenTemplate, true);\r\n    pieceUpcoming = foo;\r\n}\r\n\r\nfunction storePiece() {\r\n    let pieceToStore = pieceInPlay;\r\n    addPieceToBoard(pieceStored != undefined);\r\n    swappedThisTurn = true;\r\n    pieceStored = pieceToStore;\r\n    pieceStored.stored = true;\r\n    pieceStored.setPos(0, 0);\r\n    clearInterval(tickTimer);\r\n    tickTimer = undefined;\r\n    tick();\r\n    skipTicks++;\r\n}\r\n\r\nfunction addPieceToBoard(fromStorage: boolean = false) {\r\n    if (fromStorage) {\r\n        pieceInPlay = pieceStored;\r\n        pieceInPlay.setPos(3, 0);\r\n        pieceInPlay.stored = false;\r\n    } else {\r\n        pieceInPlay = pieceUpcoming;\r\n        pieceInPlay.setPos(3, 0)\r\n        pieceInPlay.waiting = false;\r\n        addPieceToWaiting();\r\n        okayToAddPiece = false;\r\n    }\r\n}\r\n\r\nfunction convertPiece(piece: PieceInPlay): boolean {\r\n    const continueGame = piece.convert(board);\r\n    if (continueGame) {\r\n        pieceInPlay = undefined;\r\n        okayToAddPiece = true;\r\n    }\r\n    piece.draw(0, 0, board);\r\n    addToScore(5);\r\n    return continueGame;\r\n}\r\n\r\nfunction clearLines() {\r\n    let currentLinesCleared = 0;\r\n    let fullLine = scanForFullLines();\r\n    while (fullLine >= 0) {\r\n        currentLinesCleared += 1;\r\n        for (let i = fullLine; i > 0; i--) {\r\n            for (let j = 0; j < board.state[i].length; j++) {\r\n                if (board.state[i - 1][j]) {\r\n                    board.state[i][j] = board.state[i - 1][j];\r\n                    board.state[i][j].y += 1;\r\n                } else {\r\n                    board.state[i][j] = undefined;\r\n                }\r\n            }\r\n        }\r\n        // Clear the top row\r\n        for (let j = 0; j < board.state[0].length; j++) {\r\n            board.state[0][j] = undefined;\r\n        }\r\n        fullLine = scanForFullLines();\r\n    }\r\n    addToScore(currentLinesCleared == 5 ? currentLinesCleared * 125 : currentLinesCleared * 25);\r\n    increaseLinesCleared(currentLinesCleared);\r\n    swappedThisTurn = false;\r\n}\r\n\r\nfunction addToScore(points: number) {\r\n    score += points;\r\n    setScore(score);\r\n}\r\n\r\nfunction setScore(score: number) {\r\n    document.getElementById(\"score-value\").innerHTML = score.toString();\r\n}\r\n\r\nfunction increaseLinesCleared(lines: number) {\r\n    linesCleared += lines;\r\n    setLevel(Math.floor(linesCleared / 5) + 1);\r\n}\r\n\r\nfunction setLevel(level: number) {\r\n    document.getElementById(\"level-value\").innerHTML = level.toString();\r\n    tickTime = Math.max(50, 1000 - (50 * (level + 1)));\r\n    clearInterval(tickTimer);\r\n    startTickTimer();\r\n}\r\n\r\nfunction scanForFullLines(): number {\r\n    for (let i = 0; i < board.state.length; i++) {\r\n        let complete = true;\r\n        for (let j = 0; j < board.state[i].length; j++) {\r\n            if (!board.state[i][j]) {\r\n                complete = false;\r\n                break;\r\n            }\r\n        }\r\n        if (complete) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}\r\n\r\nfunction doGameOver() {\r\n    clearInterval(tickTimer);\r\n    tickTimer = undefined;\r\n    const gameOverSvg = <SVGElement><unknown>document.getElementById(\"game-over\").cloneNode(true);\r\n    svgMain().append(gameOverSvg);\r\n    document.getElementById(\"pause-button\").innerHTML = \"Restart\";\r\n    isGameOver = true;\r\n    board.clear();\r\n}\r\n\r\nexport function togglePause() {\r\n    if (isGameOver) {\r\n        svgMain().innerHTML = \"\";\r\n        gameTicks = 0;\r\n        score = 0;\r\n        linesCleared = 0;\r\n        setScore(0);\r\n        setLevel(0);\r\n        isGameOver = false;\r\n        isPaused = false;\r\n        tickTime = 1000;\r\n        startTickTimer();\r\n        document.getElementById(\"pause-button\").innerHTML = \"Pause\";\r\n        return;\r\n    }\r\n    isPaused = !isPaused;\r\n    if (isPaused) {\r\n        doPause();\r\n    } else {\r\n        undoPause();\r\n    }\r\n}\r\n\r\nfunction doPause() {\r\n    document.getElementById(\"pause-button\").innerHTML = \"Resume\";\r\n    clearInterval(tickTimer);\r\n    tickTimer = undefined;\r\n    const pauseSvg = <SVGElement><unknown>document.getElementById(\"pause\").cloneNode(true);\r\n    pauseSvg.id = \"pause-copy\";\r\n    svgMain().append(pauseSvg);\r\n}\r\n\r\nfunction undoPause() {\r\n    document.getElementById(\"pause-button\").innerHTML = \"Pause\";\r\n    document.getElementById(\"pause-copy\")?.remove();\r\n    startTickTimer();\r\n}\r\n\r\nfunction startTickTimer() {\r\n    clearInterval(tickTimer);\r\n    tickTimer = setInterval(tick, tickTime);\r\n    tick();\r\n}\r\n\r\nfunction tick() {\r\n    if (skipTicks <= 0) {\r\n\r\n        if (isGameOver) {\r\n            doGameOver();\r\n            return;\r\n        }\r\n\r\n        svgMain().innerHTML = \"\";\r\n        svgUpcoming().innerHTML = \"\";\r\n        svgStorage().innerHTML = \"\";\r\n\r\n        // Draw all stationary squares.\r\n        for (let i = 0; i < board.state.length; i++) {\r\n            for (let j = 0; j < board.state[i].length; j++) {\r\n                if (board.state[i][j] != undefined) {\r\n                    board.state[i][j].draw(0, 0, board, svgMain());\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!isPaused) {\r\n            if (pieceInPlay) {\r\n                pieceInPlay.ticksAlive++;\r\n                if (pieceInPlay.canMove(0, 1, board)) {\r\n                    if (pieceInPlay.ticksAlive * tickTime > 1000 && !skipNextDown) {\r\n                        pieceInPlay.move(0, 1, board);\r\n                    }\r\n                } else {\r\n                    convertAndClearLines();\r\n                    if (!isGameOver) {\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (okayToAddPiece) {\r\n                addPieceToBoard();\r\n            }\r\n        }\r\n\r\n        pieceUpcoming.draw(0, 0, board);\r\n\r\n        if (pieceInPlay) {\r\n            pieceInPlay.draw(0, 0, board);\r\n        }\r\n\r\n        if (pieceStored) {\r\n            pieceStored.draw(0, 0, board);\r\n        }\r\n\r\n        skipNextDown = false;\r\n        gameTicks++;\r\n    } else {\r\n        skipTicks--;\r\n    }\r\n}\r\n\r\nfunction convertAndClearLines() {\r\n    isGameOver = !convertPiece(pieceInPlay);\r\n    clearLines();\r\n    clearInterval(touchTimer);\r\n    touchTimer = undefined;\r\n    cancelNext = true;\r\n}\r\n\r\nfunction addEventListeners() {\r\n\r\n    const pauseButton: HTMLButtonElement = <HTMLButtonElement><unknown>document.getElementById(\"pause-button\");\r\n\r\n    [\"mousedown\", \"touchstart\", \"pointerdown\"].forEach(eventName => {\r\n        svgStorage().addEventListener(eventName, (event) => {\r\n            mouseDownInStorage = true;\r\n        });\r\n        pauseButton.addEventListener(eventName, (event) => {\r\n            mouseDownOverPauseButton = true;\r\n        });\r\n    });\r\n    [\"mouseup\", \"touchend\", \"pointerup\"].forEach(eventName => {\r\n        svgStorage().addEventListener(eventName, (event) => {\r\n            if (mouseDownInStorage && !swappedThisTurn) {\r\n                storePiece();\r\n                rotatePiece();\r\n                rotatePiece();\r\n                rotatePiece();\r\n            }\r\n            mouseDownInStorage = false;\r\n        });\r\n        pauseButton.addEventListener(eventName, (event) => {\r\n            mouseDownOverPauseButton = false;\r\n        });\r\n    });\r\n    [\"mouseleave\", \"touchcancel\", \"pointercancel\"].forEach(eventName => {\r\n        svgStorage().addEventListener(eventName, (event) => {\r\n            mouseDownInStorage = false;\r\n        });\r\n        pauseButton.addEventListener(eventName, (event) => {\r\n            mouseDownOverPauseButton = false;\r\n        });\r\n    });\r\n\r\n    // Event listener for keyboard input\r\n    document.addEventListener(\"keydown\", event => {\r\n        if (!isGameOver && pieceInPlay) {\r\n            if (event.code == \"Escape\") {\r\n                togglePause();\r\n            }\r\n            if (!isPaused) {\r\n                if (event.code == \"ArrowLeft\" || event.code == \"KeyA\") {\r\n                    movePieceLeft();\r\n                } else if (event.code == \"ArrowRight\" || event.code == \"KeyD\") {\r\n                    movePieceRight();\r\n                } else if (event.code == \"ArrowDown\" || event.code == \"KeyS\") {\r\n                    movePieceDown();\r\n                } else if (event.code == \"ArrowUp\" || event.code == \"KeyW\") {\r\n                    rotatePiece();\r\n                } else if (event.code == \"Space\") {\r\n                    dropPiece();\r\n                } else if (event.code == \"Tab\" && !swappedThisTurn) {\r\n                    storePiece();\r\n                }\r\n            }\r\n            event.preventDefault();\r\n        }\r\n    });\r\n\r\n\r\n    // Mouse/touch move.\r\n    [\"mousemove\", \"touchmove\", \"pointermove\", \"drag\"].forEach(eventName => {\r\n        document.addEventListener(eventName, function (event: MouseEvent | TouchEvent | PointerEvent | DragEvent) {\r\n            if (event instanceof TouchEvent) {\r\n                touchEndX = event.changedTouches[0].clientX;\r\n                touchEndY = event.changedTouches[0].clientY;\r\n            } else {\r\n                if (mouseDownOverPauseButton) return;\r\n                touchEndX = event.clientX;\r\n                touchEndY = event.clientY;\r\n            }\r\n        });\r\n    });\r\n\r\n    // Mouse/touch down.\r\n    [\"mousedown\", \"touchstart\", \"pointerdown\"].forEach(eventName => {\r\n        document.addEventListener(eventName, function (event: MouseEvent | TouchEvent | PointerEvent | DragEvent) {\r\n            if (touchTimer == undefined) {\r\n                cancelNext = false;\r\n                if (event instanceof TouchEvent) {\r\n                    touchStartX = event.touches[0].clientX;\r\n                    touchStartY = event.touches[0].clientY;\r\n                } else {\r\n                    if (mouseDownOverPauseButton) return;\r\n                    touchStartX = event.clientX;\r\n                    touchStartY = event.clientY;\r\n                }\r\n                timeDown = 0;\r\n                clearInterval(touchTimer);\r\n                touchTimer = setInterval(touchTimerUpdater, touchTime);\r\n            }\r\n            cancelNext = false;\r\n        });\r\n    });\r\n\r\n    // Mouse/touch up.\r\n    [\"mouseup\", \"mouseleave\", \"touchend\", \"touchcancel\", \"pointerup\", \"pointercancel\"].forEach(eventName => {\r\n        document.addEventListener(eventName, function (event: MouseEvent | TouchEvent | PointerEvent | DragEvent) {\r\n            if (event instanceof TouchEvent) {\r\n                touchEndX = event.changedTouches[0].clientX;\r\n                touchEndY = event.changedTouches[0].clientY;\r\n            } else {\r\n                if (mouseDownOverPauseButton) return;\r\n                touchEndX = event.clientX;\r\n                touchEndY = event.clientY;\r\n            }\r\n            clearInterval(touchTimer);\r\n            touchTimer = undefined;\r\n            cancelNext = true;\r\n            handleMouseAndTouch();\r\n        });\r\n    });\r\n\r\n}\r\n\r\nfunction touchTimerUpdater() {\r\n    actionHandled = false;\r\n    timeDown += touchTime;\r\n    if (timeDown % 200 == 0) {\r\n        handleMouseAndTouch();\r\n    }\r\n}\r\n\r\nfunction handleMouseAndTouch() {\r\n    if (!isGameOver && !isPaused && pieceInPlay && !actionHandled) {\r\n        const deltaX = touchEndX - touchStartX;\r\n        const deltaY = touchEndY - touchStartY;\r\n\r\n        // Determine if the swipe was primarily horizontal or vertical\r\n        if (Math.abs(deltaX) > Math.abs(deltaY)) {\r\n            // Horizontal swipe\r\n            if (deltaX > 50 && !cancelNext) {\r\n                movePieceRight();\r\n            } else if (deltaX < -50 && !cancelNext) {\r\n                movePieceLeft();\r\n            } else if (timeDown < 250) {\r\n                rotatePiece();\r\n            }\r\n        } else {\r\n            // Vertical swipe\r\n            if (deltaY > 50 && !cancelNext) {\r\n                movePieceDown();\r\n            } else if (deltaY < -50 && timeDown < 250) {\r\n                dropPiece();\r\n            } else if (timeDown < 250) {\r\n                rotatePiece();\r\n            }\r\n        }\r\n        actionHandled = true;\r\n        cancelNext = false;\r\n    }\r\n}\r\n\r\nfunction movePieceLeft() {\r\n    if (pieceInPlay.canMove(-1, 0, board)) {\r\n        pieceInPlay.move(-1, 0, board);\r\n        redrawPieceInPlay();\r\n    }\r\n}\r\n\r\nfunction movePieceRight() {\r\n    if (pieceInPlay.canMove(1, 0, board)) {\r\n        pieceInPlay.move(1, 0, board);\r\n        redrawPieceInPlay();\r\n    }\r\n}\r\n\r\nfunction movePieceDown() {\r\n    if (pieceInPlay.canMove(0, 1, board)) {\r\n        pieceInPlay.move(0, 1, board);\r\n        redrawPieceInPlay();\r\n        skipNextDown = true;\r\n    }\r\n}\r\n\r\nfunction dropPiece() {\r\n    if (pieceInPlay.canMove(0, 1, board)) {\r\n        for (let i = 0; i < pieceInPlay.squares.length; i++) {\r\n            pieceInPlay.squares[i].svgElement.remove();\r\n        }\r\n        pieceInPlay.drop(board);\r\n        skipTicks++;\r\n        convertAndClearLines();\r\n    }\r\n}\r\n\r\nfunction rotatePiece() {\r\n    for (let i = 0; i < pieceInPlay.squares.length; i++) {\r\n        pieceInPlay.squares[i].svgElement.remove();\r\n    }\r\n    pieceInPlay.rotate(board);\r\n    pieceInPlay.draw(0, 0, board);\r\n}\r\n\r\nfunction redrawPieceInPlay() {\r\n    for (let i = 0; i < pieceInPlay.squares.length; i++) {\r\n        pieceInPlay.squares[i].svgElement.remove();\r\n    }\r\n    pieceInPlay.draw(0, 0, board);\r\n}"],"names":["constructor","squareSize","width","height","state","this","clear","i","j","undefined","PieceTemplate","shape","fill","weight","Square","x","y","isShadow","draw","board","svgCanvas","waiting","createSquare","size","opacity","rectElement","document","createElementNS","setAttribute","toString","svgElement","svgBorderTL","svgBorderBR","svgBorderBL","svgBorderTR","svgBorderFill","svgBorderOverlay","append","canMove","newX","newY","newSpaceOccupied","leftWallCrossed","rightWallCrossed","ceilingCrossed","floorCrossed","move","setPos","svgMain","getElementById","svgUpcoming","svgStorage","template","squares","shadowSquares","stored","ticksAlive","length","push","drawShadow","remove","yOffset","minX","Math","min","map","square","minY","currentSquare","drop","convert","rotate","offsetX","offsetY","output","rotate2DArray","newSquares","maxX","max","maxY","moveX","moveY","every","array","result","forEach","a","aa","b","bb","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","async","templates","fetch","json","pieceTemplate","colorCombos","randomIndices","allTemplates","setupPieceTemplates","boardSize","upcomingSize","storageSize","addPieceToWaiting","pauseButton","eventName","addEventListener","event","mouseDownInStorage","mouseDownOverPauseButton","swappedThisTurn","storePiece","rotatePiece","isGameOver","pieceInPlay","code","togglePause","isPaused","movePieceLeft","movePieceRight","movePieceDown","dropPiece","preventDefault","TouchEvent","touchEndX","changedTouches","clientX","touchEndY","clientY","touchTimer","cancelNext","touchStartX","touches","touchStartY","timeDown","clearInterval","setInterval","touchTimerUpdater","touchTime","handleMouseAndTouch","addEventListeners","random","floor","indexOf","Board","tickTimer","pieceUpcoming","pieceStored","tickTime","okayToAddPiece","score","linesCleared","gameTicks","actionHandled","skipNextDown","skipTicks","totalWeight","reduce","sum","chosenTemplate","currentValue","entries","set","Map","range","foo","PieceInPlay","pieceToStore","addPieceToBoard","tick","fromStorage","addToScore","points","setScore","innerHTML","setLevel","level","startTickTimer","scanForFullLines","complete","pauseSvg","cloneNode","id","doPause","gameOverSvg","doGameOver","convertAndClearLines","piece","continueGame","convertPiece","currentLinesCleared","fullLine","clearLines","deltaX","deltaY","abs","redrawPieceInPlay"],"sourceRoot":""}